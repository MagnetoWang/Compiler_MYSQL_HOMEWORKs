/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */
options
{
  static = true;
}

PARSER_BEGIN(MySQL)

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Polygon;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.security.spec.EncodedKeySpec;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Scanner;
import java.util.Set;

public class MySQL
{
  public static void main(String args []) throws ParseException
  {
   
    MySQL parser;
    
      parser = new MySQL(System.in);
      System.out.println("============================");
      System.out.println("欢迎使用简单版本的MYSQL编译器");
      System.out.println("版本号：0049");
      System.out.println("Welcome to the easy MYSQL");
      System.out.println("Version 0049");





      System.out.println("============================");
       while (true)
    {
      // System.out.println("Reading from standard input...");
      System.out.println();
      System.out.print("MYSQL>>");
      // System.out.println();
      try
      {
        MySQL.one_line();

      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        MySQL.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
  }
  
}

PARSER_END(MySQL)



//TOKEN: 这个产生式中的正则表达式描述了tokens的语法，主要定义语法分析阶段用到的非终结符。 
//Token Manager会根据这些正则表达式生成 Token 对象并返回给parser。
//SPECIAL_TOKEN: 这产生式中的正则表达式描述了特殊的Token。特殊的Token是在解析过程中没有意义的Token，也就是本BNF产生式忽略的Token。但是，这些Token还是会被传递给parser，并且parser也可以访问他们。访问特殊Token的方式是通过其相邻的Token的specialToken域。特殊Token在处理像注释这种token的时候会非常有用。可以参考这个文档以了解更多关于特殊token的知识。
//SKIP: 这个产生式的规则命中的Token会被Token Manager丢弃掉。
//MORE: 有时候会需要逐步地构建Token。被这种规则命中的Token会存到一个Buffer中，直到遇到下一个Token或者Special_token，然后他们和最后一个Token或者Special_token会连在一起作为一个Token返回给parser。如果一个More后面紧跟了一个SKIP，那么整个Buffer中的内容都会被丢弃掉。
//


ControlSQL CompilationUnit() : {
Token head ;
} {
  "HEADER"
{ head = getToken( 1 ) ; 
System.out.println(head);}

{ return new ControlSQL( head, getToken(0) ) ; }
}


SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}



TOKEN : //创建库，表。
{
      <CREATE:"CREATE">
  |   <DATABASE:"DATABASE">
  |   <SHOW:"SHOW">
  |   <DATABASES:"DATABASES">
  |   <DROP:"DROP">
  |   <USE:"USE">
  |   <TABLE:"TABLE">
  |   <TABLES:"TABLES">
  |   <INSERT:"INSERT">  
  |   <AND: "AND">
  |   <ANY: "ANY">
  |   <AS: "AS">
  |   <ASC:"ASC">
  |   <BEGIN: "BEGIN">
  |   <BETWEEN:"BETWEEN">
  |   <BINARY_INTEGER: "BINARY_INTEGER">
  |   <BOOLEAN:"BOOLEAN">
  |   <BY:"BY">
  |   <CHAR:"CHAR">
  |   <CLOSE:"CLOSE">
  |   <COMMENT:"COMMENT">
  |   <COMMIT:"COMMIT">
  |   <CONNECT:"CONNECT">
  |   <CONSTANT:"CONSTANT">
  |   <CURRENT:"CURRENT">
  |   <CURSOR:"CURSOR">
  |   <DATE:"DATE">
  |   <DECIMAL:"DECIMAL">
  |   <DELETE:"DELETE">
  |   <DESC:"DESC">
  |   <DISTINCT:"DISTINCT">
  |   <DO:"DO">
  |   <ELSE:"ELSE">
  |   <ELSIF:"ELSIF">
  |   <END:"END">
  |   <EXCEPTION:"EXCEPTION">
  |   <EXCEPTION_INIT:"EXCEPTION_INIT">
  |   <EXCLUSIVE:"EXCLUSIVE">
  |   <EXISTS:"EXISTS">
  |   <EXIT:"EXIT">
  |   <FETCH:"FETCH">
  |   <FLOAT:"FLOAT">
  |   <FOR:"FOR">
  |   <FROM:"FROM">
  |   <FUNCTION:"FUNCTION">
  |   <GOTO:"GOTO">
  |   <GROUP:"GROUP">
  |   <HAVING:"HAVING">
  |   <INTERSECT:"INTERSECT">
  |   <INTO:"INTO">
  |   <IS:"IS">
  |   <LEVEL:"LEVEL">
  |   <LIKE:"LIKE">
  |   <LOCK:"LOCK">
  |   <LOOP:"LOOP">
  |   <MINUS:"MINUS">
  |   <MODE:"MODE">
  |   <NATURAL:"NATURAL">
  |   <NOT:"NOT">
  |   <NOWAIT:"NOWAIT">
  |   <NULL:"NULL">
  |   <NUMBER:"NUMBER">
  |   <OF:"OF">
  |   <ONLY:"ONLY">
  |   <OPEN:"OPEN">
  |   <OR:"OR">
  |   <ORDER:"ORDER">
  |   <OTHERS:"OTHERS">
  |   <OUT:"OUT">
  |   <PACKAGE:"PACKAGE">
  |   <POSITIVE:"POSITIVE">
  |   <PRAGMA:"PRAGMA">
  |   <PRIOR:"PRIOR">
  |   <PROCEDURE:"PROCEDURE">
  |   <RAISE:"RAISE">
  |   <READ:"READ">
  |   <REAL:"REAL">
  |   <RECORD:"RECORD">
  |   <REF:"REF">
  |   <RETURN:"RETURN">
  |   <REVERSE:"REVERSE">
  |   <ROLLBACK:"ROLLBACK">
  |   <ROW:"ROW">
  |   <SAVEPOINT:"SAVEPOINT">
  |   <SEGMENT:"SEGMENT">
  |   <SELECT:"SELECT">
  |   <SET:"SET">
  |   <SHARE:"SHARE">
  |   <SMALLINT:"SMALLINT">
  |   <SQL:"SQL">
  |   <THEN:"THEN">
  |   <TO:"TO">
  |   <TRANSACTION:"TRANSACTION">
  |   <UNION:"UNION">
  |   <UPDATE:"UPDATE">
  |   <VARCHAR2:"VARCHAR2">
  |   <VARCHAR:"VARCHAR">
  |   <WHEN:"WHEN">
  |   <WHERE:"WHERE">
  |   <WHILE:"WHILE">
  |   <WITH:"WITH">
  |   <WORK:"WORK">
  |   <WRITE:"WRITE">
  
  |   <MYSQL_OVER:"MYSQL_OVER">
  |   <LEFTBRCKET:"(">
  |   <RIGHTBRCKET:")">
  |   <INT:"INT">
  |   <VALUES:"VALUES">
  |   <SingleQuotes:"'">
  |   <ALL:"ALL">
  |   <DISTINCTROW:"DISTINCTROW">
  |   <TOP:"TOP"> 

}
TOKEN : /* Numeric Constants */
{	
   		< SQL_CONSTANT: ( <DIGIT> )+ >
  | 	< DIGIT: ["0" - "9"] >
 

}

SPECIAL_TOKEN://描述注释
{
   <LINE_COMMENT: "--"(~["\r","\n"])*>
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}



TOKEN://描述标识符
{
	< SQL_IDENTIFIER: ( <LETTER> )+ ( <DIGIT> | <LETTER> |<SPECIAL_CHARS>)* >
| 	< #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: "$" | "_">
|   < SQL_BIND: ":" <SQL_IDENTIFIER> ("." <SQL_IDENTIFIER>)? >
|   < SQL_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
|   < SQL_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}


// TOKEN://表述逻辑符号
// {
//   < COMPARE:"=">//(["="]["!="]["<>"][">"][">="]["<"]["<="]) >
// }

void compare():
{}
{
  "=" | "!="  | "<>" | ">" | ">=" | "<" | "<="
}


int input():
{}
{
  ";" { System.out.println(" call function ");
      return 0;}
}

//用来循环处理命令
//参考自带的模板
void one_line() :
{}
{
  Statement()

}

void TestStatement() :
{}
{
  CompilationUnit()";"{
    System.out.println("CompilationUnit");
  }

}

void Statement():
{}{
  TestStatement()
  |
  CreadStatement()
  // {
  //   System.out.println("begin CreadStatement");
  // }
  |
  ShowStatement()
  // {
    
  //   System.out.println("begin ShowStatement");
  // }
  |
  USEStatement()
  |
  DropStatement()
  |
  InsertStatement()
  |
  SelectStatement()
  |
  DeleteStatement()
  |
  UpdateStatement()

}

void STOPStatement():
{}{
    "MYSQL_OVER"";"{
      System.out.println("EXIT");
    }
}

void CreadStatement():
{}{
      "CREATE" (CreatTable()|CreatDatabase()) ";"
      

}

void CreatTable():
{
  Token creatToken;
}{
  "TABLE"
  TableItem() 
  {

  }

}
void TableItem():
{}{ 

  IdentifierItem()
  {System.out.println("TableName");
  System.out.println(MySQL.token);
  }
 [ <LEFTBRCKET>
  AttributeItem()
  <RIGHTBRCKET>
  {
    System.out.println("create A table with AttributeItem ");
  }]



}
//这里声明列表的时候，容易犯错误
//比如 格式上应该是 标识符-变量-变量值 应该看作一个整体
//之前把标识符和变量分开了。导致无法识别循环识别第二个列表属性
void AttributeItem():
{}
{
  {System.out.println("============================");}
  {System.out.println("AttributeItems");}
  
  BasicDataTypeDeclaration() 
  ("," BasicDataTypeDeclaration() )*

  
  {System.out.println("============================");}

}

void BasicDataTypeDeclaration():
{}
{
  
   ( IdentifierItem() 
   {
   
 
    System.out.println(MySQL.token);

    
  }
  {if(MySQL.token!=null){
    System.out.println(MySQL.token.next);

  }}

    ( (       "CHAR"
        |   "VARCHAR"
        |   "VARCHAR2"
        |   "REAL"
        |   "FLOAT" 
    ) [ "(" <SQL_CONSTANT>  ")" ]

    |   "INT"
    |   "DATE"
    |   "BINARY_INTEGER"
    |   "BOOLEAN" )
    )
    // {if(MySQL.token.image!=")")
    //   System.out.println(MySQL.token);
    // }


   
}

void CreatDatabase():
{}{
  "DATABASE"IdentifierItem()
  {
    System.out.println("create A database");
  }
}

void ShowStatement():
{  }
{
  "SHOW" (ShowDatabases()|ShowTables()) ";"
  {
    
    System.out.println("ShowStatement");
    
  }
}

void ShowDatabases():
{}{
  "DATABASES" 
  {
    System.out.println("ShowDatabases");
  }
}




void ShowTables():
{}{
 "TABLES"
 {
  System.out.println("ShowTables");
 }
}




void DropStatement():
{}{
 "DROP" (DropDatabase()|DropTable())
}



void DropDatabase():
{}{
  "DATABASE" (IdentifierItem())";"
  {
    System.out.println("DropDatabase");
  }
}






void DropTable():
{}{
  "TABLE" (IdentifierItem())";"
  {
    System.out.println("DropTable");
  }
}





void USEStatement ():
{}{
 "USE" IdentifierItem()";"
 {
   System.out.println("USEStatement");
 }
}




//INSERT
//INSERT INTO 表名称 VALUES (值1, 值2,....)
//INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)

void InsertStatement():
{}
{
  "INSERT" "INTO"  IdentifierItem() (TableValues()|TableColumns()) ";" 
  {
    System.out.println("insert value");
  }
}


void TableValues():
{}{
   "VALUES"
  "("
   TableValue() ("," TableValue())*
  ")"
}

void TableValue():
{}{
  (
    (IdentifierItem())*
    
    // <SingleQuotes> <SQL_IDENTIFIER> <SingleQuotes>
    // ObjectName()  |
  //  (<SQL_CHAR_LITERAL>IdentifierItem() <SQL_CHAR_LITERAL>)
   
  )
}


void TableColumns():
{}{
   "("
   TableColumn()("," TableColumn())*
   ")"
   TableValues(){
     System.out.println("INSERT columns ");
   }

}

void TableColumn():
{}{
  IdentifierItem()
}

// void TableColumn():
// {}
// {
//     // user.table.column
//     ObjectName() [ "." ObjectName() ["." ObjectName()]]
// }



//SELECT 列名称 FROM 表名称
//SELECT * FROM 表名称
//SELECT 列名称 FROM 表名称 WHERE 列 运算符 值
//SELECT * FROM Persons WHERE FirstName='Thomas' AND LastName='Carter'
//SELECT Company, OrderNumber FROM Orders ORDER BY Company



// SELECT[ALL|DISTINCT|DISTINCTROW|TOP]
// {*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]}
// FROM tableexpression[,…][IN externaldatabase]
// [WHERE…]
// [GROUP BY…]
// [HAVING…]
// [ORDER BY…]

void SelectStatement():
{}
{
  "SELECT" ["ALL"|"DISTINCT"|"DISTINCTROW"|"TOP"]
   SelectBaseStatement()
   ";"
   {
    System.out.println(" selectStatement OVER");
  }


}

void SelectBaseStatement():
{}
{
  SelectList()
  "FROM"
  TableList()
  //该加中括号的要加
  [WhereStatement()]
//  [ WhereStatement() ]
//  [ GroupByStatement() ]
// 
//


  



}
//表名 单独处理
void TableList():
{}
{
//  IdentifierItem()("," IdentifierItem())*
//  TableItem()//("," TableItem())*
  SelectTableItem()("," SelectTableItem())*
    {
    System.out.println(" selectBase ");
  }

}

//注意不要重名
//void TableItem():
//{}
//{
//  IdentifierItem()
//}

void SelectTableItem():
{}
{
  IdentifierItem()
}

//列名 单独处理
void SelectList():
{}
{
    "*" | (SelectItem() ("," SelectItem())*)
}

void SelectItem():
{}
{
  IdentifierItem()
}

// 比较运算符	=,<,>,<=,>=,<>	比较两个表达式
// 逻辑运算符	AND ,OR, NOT	组合两个表达式的运算结果或取反
// 范围运算符	BETWEEN,NOT BETWEEN	搜索值是否在范围内
// 列表运算符	IN,NOT IN	查询值是否属于列表值之一
// 字符匹配符	LIKE ,NOT LIKE	字符串是否匹配
// 未知值	IS NULL ,IS NOT NULL	查询值是否为NULL
void WhereStatement():
{}
{
  "WHERE"
  
  SQLCondition()(SQLCondition())*
  {
    System.out.println("where OVER");
  }

  
}
// %	任意多个字符	H% 表示查询以H开头的任意字符串,如Hello ―C %h 表示查询以h结尾的任意字符串，如Growth ―― %h% 表示查询在任何位置包含字母的h的所有字C符串，如hui，zhi
// _	单个字符	H_ 表示查询以H开头，后面跟任意一个字符的两位字符串，如Hi，He
// []	指定范围的单个字符	H[ea]% 表示查询以H开头，第二个字符是e或a的所有字符串，如：Health，Hand ―――- [A-G]% 表示查询以A到G之间的任意字符开头的所有字符串，如：Apple，Banana，Guide
// [^]	不在指定范围的单个字符	H[^ea]% 表示查询以H开头，的一个字符不是e或a的所有字符串，如：Hope，Hub ――― [^A_G]% 表示查询不是以A到G之间的任意字符开头的字符串，如；Job，Zoo


//这里SQLCondition 和  SQLLogicalExpression 
//内部都有括号 所以容易产生冲突
void SQLCondition():
{}
{
//  ( "(" )*
  
  (
   SQLLogicalExpression() 
  | "AND" SQLLogicalExpression()
  | "OR" SQLLogicalExpression()

  )
  
//  ( ")" )*
}
//逻辑表达式
void SQLLogicalExpression():
{}
{
  ( "(" )*

  (IdentifierItem()
  compare()
  IdentifierItem())
  

  ( ")" )*

}


void GroupByStatement():
{}
{
  "GROUP" "BY"
//  IdentifierItem()
}



void HAVINGStatement():
{}
{
  "HAVING" 
//  IdentifierItem()
}

void OrderByStatement():
{}
{
  "ORDER" "BY"
//  IdentifierItem()
}




//DELETE FROM 表名称 WHERE 列名称 = 值
void DeleteStatement():
{}
{
  "DELETE"
  [SelectList()]
   "FROM"
  TableList()
  [WhereStatement()]
//  IdentifierItem()
  ";"
  {
    System.out.println("DeleteStatement OVER");
  }

}





//UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
void UpdateStatement():
{}
{
  "UPDATE"
  TableList()
  "SET"
  SQLCondition()("," SQLCondition())*
  [WhereStatement()]
//  IdentifierItem()


  ";"
  {
    System.out.println("UpdateStatement OVER");
  }


}



void ObjectName():
{}
{
    <SQL_IDENTIFIER> | <SQL_QUOTED_IDENTIFIER>
}



void IdentifierItem():
{}
{
  (<SQL_IDENTIFIER> ["." <SQL_IDENTIFIER>] )
  |  (<SQL_BIND>)
  | ( <SingleQuotes> <SQL_IDENTIFIER> <SingleQuotes>)
  | (<SQL_CHAR_LITERAL>)
  |  < SQL_CONSTANT>
}



// void CreatTable():
// {}{
 
// }


// void CreatTable():
// {}{
 
// }





// void CreatTable():
// {}{
 
// }


